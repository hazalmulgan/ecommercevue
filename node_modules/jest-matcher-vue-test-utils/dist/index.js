'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var diff = _interopDefault(require('jest-diff'));
var testUtils = require('@vue/test-utils');

let configuration = {
    mountOptions: {}
};
function setConfig(overwrite) {
    configuration = overwriteConfiguration(overwrite);
}
const getConfiguration = () => {
    return {
        mountOptions: configuration.mountOptions
    };
};
const overwriteConfiguration = (overwrite) => {
    return {
        mountOptions: Object.assign(Object.assign({}, getConfiguration().mountOptions), overwrite.mountOptions)
    };
};

const storeKey = "jestMatcherVueTestUtils";
const defineLogger = (store) => {
    const log = {
        dispatched: []
    };
    store.subscribeAction((action, _state) => {
        log.dispatched.push(action);
    });
    Object.defineProperty(store, storeKey, {
        value: log,
        writable: false,
        enumerable: true,
        configurable: false
    });
};
const generatePlugin = () => (store) => defineLogger(store);

function toShow (action, wrapper, findArgument) {
    const before = wrapper.contains(findArgument);
    action();
    const after = wrapper.contains(findArgument);
    let message;
    let result;
    if (before) {
        message = "The target has been showing from the beginning";
        result = false;
    }
    else if (!after) {
        message = "The action doesn't show the target";
        result = false;
    }
    else {
        message = "The action shows the target";
        result = true;
    }
    return {
        message: () => message,
        pass: result
    };
}

function toHide (action, wrapper, findArgument) {
    const before = wrapper.contains(findArgument);
    action();
    const after = wrapper.contains(findArgument);
    let message;
    let result;
    if (!before) {
        message = "The target has been hiding from the beginning";
        result = false;
    }
    else if (after) {
        message = "The action doesn't hide the target";
        result = false;
    }
    else {
        message = "The action hides the target";
        result = true;
    }
    return {
        message: () => message,
        pass: result
    };
}

function toEmit (func, wrapper, eventName, ...payloads) {
    const before = wrapper.emitted()[eventName] ? wrapper.emitted()[eventName].slice(0) : [];
    func();
    const after = wrapper.emitted()[eventName] ? wrapper.emitted()[eventName].slice(0) : [];
    const emitted = after.slice(before.length, after.length);
    let pass;
    let message;
    if (arguments.length >= 4) {
        const matchesToPayload = (event) => {
            return payloads.length === event.length &&
                payloads.every((payload, index) => {
                    return this.equals(event[index], payload);
                });
        };
        pass = emitted.filter(matchesToPayload).length > 0;
        message = pass ?
            () => `The function emitted the "${eventName}" event with the expected payload` :
            emitted.length > 0 ?
                () => {
                    const diffs = emitted.map((event, i) => {
                        return `'${eventName}' event #${i} payloads:\n\n${diff(payloads, event, { bAnnotation: "Emitted" })}`;
                    }).join("\n\n");
                    return `The function emitted the "${eventName}" event, but the payload is not matched\n\n${diffs}`;
                } :
                () => `The function did not emit the "${eventName}" event`;
    }
    else {
        pass = emitted.length > 0;
        message = pass ?
            () => `The function emitted the "${eventName}" event` :
            () => `The function did not emit the "${eventName}" event`;
    }
    return {
        pass,
        message
    };
}

function toHaveEmitted (wrapper, eventName, ...payloads) {
    const emitted = wrapper.emitted()[eventName] || [];
    let pass;
    let message;
    if (arguments.length >= 3) {
        pass = emitted.some((event) => {
            return payloads.length === event.length &&
                payloads.every((payload, index) => {
                    return this.equals(event[index], payload);
                });
        });
        message = pass ?
            () => `The "${eventName}" event was emitted with the expected payload` :
            emitted.length > 0 ?
                () => {
                    const diffs = emitted.map((event, i) => {
                        return `'${eventName}' event #${i} payloads:\n\n${diff(payloads, event, { bAnnotation: "Emitted" })}`;
                    }).join("\n\n");
                    return `The "${eventName}" event was emitted but the payload is not matched\n\n${diffs}`;
                } :
                () => `The "${eventName}" event was never emitted`;
    }
    else {
        pass = emitted.length > 0;
        message = pass ?
            () => `The "${eventName}" event was emitted` :
            () => `The "${eventName}" event was never emitted`;
    }
    return {
        message,
        pass
    };
}

function toDispatch (fun, wrapper, actionType, payload) {
    let pass = false;
    let message = `The function never dispatched the "${actionType}" type on Vuex Store`;
    let unsubscribe = () => { };
    if (wrapper.vm.$store === undefined) {
        message = "The Vue instance doesn't have Vuex store";
    }
    else {
        unsubscribe = wrapper.vm.$store.subscribeAction((action, _state) => {
            if (!pass && action.type === actionType) {
                if (payload) {
                    if (this.equals(action.payload, payload)) {
                        pass = true;
                        message = `The function dispatched the "${actionType}" type on Vuex Store`;
                    }
                    else {
                        // TODO: Show diff for all dispatched payloads
                        message = `The function dispatched the "${actionType}" type but the payload is not matched on Vuex Store\n${diff(payload, action.payload, { bAnnotation: "Dispatched" })}`;
                    }
                }
                else {
                    pass = true;
                    message = `The function dispatched the "${actionType}" type on Vuex Store`;
                }
            }
        });
    }
    fun();
    unsubscribe();
    return {
        pass,
        message: () => message
    };
}

function toHaveDispatched (wrapper, actionType, payload) {
    let pass = false;
    let message = `"${actionType}" action has never been dispatched`;
    if (wrapper.vm.$store === undefined) {
        message = "The Vue instance doesn't have Vuex store";
    }
    else if (wrapper.vm.$store[storeKey] === undefined) {
        message = "The Vuex Store doesn't have the plugin by jest-matcher-vue-test-utils";
    }
    else {
        const dispatched = wrapper.vm.$store[storeKey].dispatched;
        const matched = dispatched.filter((log) => log.type === actionType);
        if (matched.length > 0) {
            if (payload) {
                const matchedPayload = matched.some((log) => this.equals(log.payload, payload));
                if (matchedPayload) {
                    pass = true;
                    message = `"${actionType}" action has been dispatched with expected payload`;
                }
                else {
                    const diffs = matched.map((action, i) => {
                        return `"${actionType}" action #${i} payloads:\n\n${diff(payload, action.payload, { bAnnotation: "Dispatched" })}`;
                    }).join("\n\n");
                    message = `"${actionType}" action has been dispatched, but payload isn't matched to the expectation\n\n${diffs}`;
                }
            }
            else {
                pass = true;
                message = `"${actionType}" action has been dispatched`;
            }
        }
    }
    return {
        pass,
        message: () => message
    };
}

const withMockWarning = (doesDuringMock) => {
    const original = console.error;
    console.error = jest.fn();
    doesDuringMock(console.error.mock);
    console.error = original;
};
const getWarningsByMount = (component, propsData, dynamicMountOptions) => {
    const mountOption = dynamicMountOptions ?
        overwriteConfiguration({ mountOptions: dynamicMountOptions }).mountOptions :
        getConfiguration().mountOptions;
    let warnings;
    withMockWarning((mock) => {
        testUtils.shallowMount(corkComponent(component), Object.assign(Object.assign({}, mountOption), { propsData }));
        warnings = mock.calls || [];
    });
    return warnings;
};
const corkComponent = (component) => {
    return {
        mixins: [component],
        template: "<h1>mocked template</h1>"
    }; // mixins is not compatible actually since that expects ComponentOptions<Vue> unintentionally
};

function toRequireProp(received, propName, dynamicMountOptions) {
    const messages = getWarningsByMount(received, {}, dynamicMountOptions);
    const found = messages.find((c) => {
        return c.find((arg) => arg.includes(`Missing required prop: "${propName}"\n`));
    });
    return {
        message: !!found ?
            () => `'${propName}' prop is claimed as required` :
            () => `'${propName}' prop is not claimed as required`,
        pass: !!found
    };
}

function toHaveDefaultProp(received, propName, defaultValue, dynamicMountOptions) {
    const mountOption = dynamicMountOptions ?
        overwriteConfiguration({ mountOptions: dynamicMountOptions }).mountOptions :
        getConfiguration().mountOptions;
    let wrapper;
    withMockWarning(() => {
        wrapper = testUtils.shallowMount(corkComponent(received), Object.assign({}, mountOption));
    });
    const given = wrapper.props()[propName];
    const matched = this.equals(given, defaultValue);
    return {
        message: matched ?
            () => `'${propName}' prop is given '${defaultValue}' as default` :
            () => `'${propName}' prop is not given '${defaultValue}' as default (is given '${given}')`,
        pass: matched
    };
}

function toBeValidProps(received, props, dynamicMountOptions) {
    const messages = getWarningsByMount(received, props, dynamicMountOptions);
    return {
        message: messages.length == 0 ?
            () => `Props are valid` :
            () => `Props are not valid`,
        pass: messages.length == 0
    };
}

function toBeValidProp(received, propName, value, dynamicMountOptions) {
    const props = {};
    props[propName] = value;
    const messages = getWarningsByMount(received, props, dynamicMountOptions);
    const found = messages.find((c) => {
        return c.find((arg) => {
            return arg.includes(`Invalid prop: type check failed for prop "${propName}".`) ||
                arg.includes(`Missing required prop: "${propName}"\n`) ||
                arg.includes(`Invalid prop: custom validator check failed for prop "${propName}".\n`);
        });
    });
    return {
        message: !!!found ?
            () => `'${propName}' is valid` :
            () => `'${propName}' is not valid`,
        pass: !!!found
    };
}

function toBeValidPropWithTypeCheck(received, propName, value, dynamicMountOptions) {
    const propsData = {};
    propsData[propName] = value;
    const messages = getWarningsByMount(received, propsData, dynamicMountOptions);
    const found = messages.find((c) => {
        return c.find((arg) => arg.includes(`Invalid prop: type check failed for prop "${propName}".`));
    });
    return {
        message: !!!found ?
            () => `'${propName}' prop is valid with '${value}'` :
            () => `'${propName}' prop is invalid with '${value}'`,
        pass: !!!found
    };
}

function toBeValidPropWithCustomValidator(received, propName, value, dynamicMountOptions) {
    const propsData = {};
    propsData[propName] = value;
    const messages = getWarningsByMount(received, propsData, dynamicMountOptions);
    const found = messages.find((c) => {
        return c.find((arg) => arg.includes(`Invalid prop: custom validator check failed for prop "${propName}".\n`));
    });
    return {
        message: !!!found ?
            () => `'${propName}' prop is valid with '${value}'` :
            () => `'${propName}' prop is invalid with '${value}'`,
        pass: !!!found
    };
}

const matchers = {
    toShow,
    toHide,
    toEmit,
    toHaveEmitted,
    toDispatch,
    toHaveDispatched,
    toBeValidProp,
    toBeValidProps,
    toRequireProp,
    toHaveDefaultProp,
    toBeValidPropWithTypeCheck,
    toBeValidPropWithCustomValidator
};

exports.config = setConfig;
exports.default = matchers;
exports.toBeValidProp = toBeValidProp;
exports.toBeValidPropWithCustomValidator = toBeValidPropWithCustomValidator;
exports.toBeValidPropWithTypeCheck = toBeValidPropWithTypeCheck;
exports.toBeValidProps = toBeValidProps;
exports.toDispatch = toDispatch;
exports.toEmit = toEmit;
exports.toHaveDefaultProp = toHaveDefaultProp;
exports.toHaveDispatched = toHaveDispatched;
exports.toHaveEmitted = toHaveEmitted;
exports.toHide = toHide;
exports.toRequireProp = toRequireProp;
exports.toShow = toShow;
exports.vuexPlugin = generatePlugin;
